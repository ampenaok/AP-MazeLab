<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AP MazeLab — Free • Unlimited • Customizable</title>
  <meta name="description" content="AP MazeLab es una herramienta online, totalmente gratuita, para crear laberintos personalizables de forma ilimitada. Ajustá parámetros y exportá puzzles en SVG/PNG para libros, educación y proyectos creativos." />
  <meta name="theme-color" content="#111827" />

<!-- Open Graph / Social Preview -->
<meta property="og:title" content="AP MazeLab — Free Maze Generator" />
<meta property="og:description" content="Create unlimited customizable mazes for books, education and creative projects. Export SVG, PNG and PDF. 100% free." />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://ampenaok.github.io/AP-MazeLab/" />
<meta property="og:image" content="https://ampenaok.github.io/AP-MazeLab/preview.png" />

<!-- Twitter -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="AP MazeLab — Free Maze Generator" />
<meta name="twitter:description" content="Create unlimited customizable mazes. Export SVG, PNG and PDF. No signup. Free." />
<meta name="twitter:image" content="https://ampenaok.github.io/AP-MazeLab/preview.png" />

<!-- Security basics -->
<meta http-equiv="Content-Security-Policy" content="
  default-src 'self';
  img-src 'self' data:;
  style-src 'self' 'unsafe-inline';
  script-src 'self' 'unsafe-inline';
  connect-src 'self';
  font-src 'self';
" />
<meta name="referrer" content="no-referrer" />

  <!-- Favicon inline (SVG data URI) -->
  <link rel="icon" href='data:image/svg+xml;utf8,
  <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64">
    <rect width="64" height="64" rx="14" fill="%23111827"/>
    <path d="M18 20h28v6H24v10h16v6H18z" fill="%23ffffff"/>
    <circle cx="46" cy="44" r="4" fill="%2306b6d4"/>
  </svg>' />

  <style>
    :root{
      --bg:#0b1220;
      --text:#e5e7eb;
      --muted:#aab3c2;
      --line:rgba(255,255,255,.10);
      --brand:#06b6d4;
      --brand2:#22c55e;
      --warn:#f59e0b;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius:16px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:var(--text);
      background: radial-gradient(1200px 600px at 20% 0%, rgba(6,182,212,.18), transparent 60%),
                  radial-gradient(900px 500px at 80% 0%, rgba(34,197,94,.12), transparent 55%),
                  linear-gradient(180deg, #070b14, var(--bg));
      min-height:100vh;
    }
    .container{max-width:1240px; margin:0 auto; padding:22px 18px 32px;}
    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:14px; flex-wrap:wrap;
      padding:16px 18px; border:1px solid var(--line); border-radius:var(--radius);
      background: rgba(15,26,46,.65); backdrop-filter: blur(8px); box-shadow: var(--shadow);
    }
    .brand{display:flex; align-items:center; gap:12px;}
    .logo{
      width:44px; height:44px; border-radius:14px; background:#111827;
      display:grid; place-items:center; border:1px solid rgba(255,255,255,.10);
    }
    .title{display:flex; flex-direction:column; line-height:1.1;}
    .title b{font-size:18px; letter-spacing:.2px}
    .title span{font-size:12px; color:var(--muted)}
    .pillrow{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    .pill{
      font-size:12px; padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      white-space:nowrap;
    }
    .pill strong{color:var(--brand)}
    .langWrap{
      display:flex; gap:10px; align-items:center;
      padding:8px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
    }
    .langWrap span{font-size:12px; color:var(--muted); white-space:nowrap;}
    .layout{
      display:grid;
      grid-template-columns: 420px 1fr;
      gap:16px;
      margin-top:16px;
    }
    @media (max-width: 1060px){ .layout{grid-template-columns:1fr} }
    .card{
      border:1px solid var(--line);
      border-radius:var(--radius);
      background: rgba(15,26,46,.60);
      backdrop-filter: blur(8px);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .cardHeader{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), transparent);
    }
    .cardHeader b{display:block; font-size:13px}
    .cardHeader small{color:var(--muted)}
    .cardBody{padding:14px}
    .grid{display:grid; grid-template-columns: 1fr 1fr; gap:12px;}
    .grid3{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px;}
    .field label{display:block; font-size:12px; color: var(--muted); margin-bottom:6px;}
    .hint{font-size:11px; color:var(--muted); margin-top:6px; opacity:.95}
    input, select, button{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(13,22,40,.8);
      color: var(--text);
      outline:none;
    }
    input:focus, select:focus{border-color: rgba(6,182,212,.65); box-shadow: 0 0 0 4px rgba(6,182,212,.12)}
    button{
      cursor:pointer;
      background: linear-gradient(180deg, rgba(6,182,212,.20), rgba(13,22,40,.8));
      border:1px solid rgba(6,182,212,.35);
    }
    button:hover{border-color: rgba(6,182,212,.7)}
    .btn2{background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.14);}
    .btnGood{background: linear-gradient(180deg, rgba(34,197,94,.20), rgba(13,22,40,.8)); border:1px solid rgba(34,197,94,.35);}
    .btnWarn{background: linear-gradient(180deg, rgba(245,158,11,.18), rgba(13,22,40,.8)); border:1px solid rgba(245,158,11,.35);}
    .actions{display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:12px;}
    .actions3{display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; margin-top:10px;}
    .note{
      margin-top:10px; padding:10px 12px; border-radius:12px;
      border:1px dashed rgba(255,255,255,.18);
      color: var(--muted); font-size:12px;
    }
    .warn{
      margin-top:10px; padding:10px 12px; border-radius:12px;
      border:1px solid rgba(245,158,11,.35);
      background: rgba(245,158,11,.08);
      color: #ffd7a1; font-size:12px; display:none;
    }
    .ok{
      border-color: rgba(34,197,94,.35) !important;
      background: rgba(34,197,94,.10) !important;
      color: #c7ffd9 !important;
    }
    .canvasWrap{padding:14px;}
    canvas{
      width:100%; height:auto;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:#fff;
    }
    .footer{
      margin-top:16px;
      text-align:center;
      color: var(--muted);
      font-size:12px;
      opacity:.95;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      padding:1px 6px; border-radius:8px; border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
    }
    .rowLine{height:1px; background:rgba(255,255,255,.10); margin:12px 0;}
    .mini{font-size:11px; color:var(--muted)}
    .chip{
      display:inline-flex; gap:6px; align-items:center;
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-size:12px; color:var(--text);
      white-space:nowrap;
    }
    .switchLine{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      padding:10px 12px; border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
    }
    .switchLine b{font-size:12px}
    .switchLine span{font-size:11px; color:var(--muted)}
    .toggle{
      width:46px; height:26px; border-radius:999px; border:1px solid rgba(255,255,255,.18);
      background: rgba(13,22,40,.8);
      position:relative; cursor:pointer;
    }
    .toggle::after{
      content:""; width:20px; height:20px; border-radius:999px;
      background: rgba(255,255,255,.80);
      position:absolute; top:2px; left:2px;
      transition: all .18s ease;
    }
    .toggle.on{
      border-color: rgba(34,197,94,.35);
      background: rgba(34,197,94,.12);
    }
    .toggle.on::after{left:24px; background: rgba(34,197,94,.95)}
  </style>
</head>

<body>
  <div class="container">
    <div class="topbar">
      <div class="brand">
        <div class="logo" aria-hidden="true">
          <svg width="26" height="26" viewBox="0 0 26 26" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="1" y="1" width="24" height="24" rx="8" fill="#111827" stroke="rgba(255,255,255,.12)"/>
            <path d="M7 8h12v3H10v4h7v3H7V8z" fill="#ffffff"/>
            <circle cx="19" cy="18.5" r="2" fill="#06b6d4"/>
          </svg>
        </div>
        <div class="title">
          <b>AP MazeLab</b>
          <span data-i18n="tagline">Free • Unlimited • Customizable maze generator</span>
        </div>
      </div>

      <div class="pillrow">
        <div class="pill"><strong data-i18n="pillFreeStrong">100% gratis</strong> • <span data-i18n="pillNoSignup">sin registro</span></div>
        <div class="pill"><span data-i18n="pillExport">Export:</span> <strong>SVG</strong> + <strong>PNG</strong> + <strong>PDF</strong></div>
        <div class="pill" data-i18n="pillShare">Compartí configs con un link</div>
      </div>

      <div class="langWrap">
        <span id="langLabel">Idioma</span>
        <select id="lang" aria-label="Language selector">
          <option value="es">Español</option>
          <option value="en">English</option>
          <option value="pt">Português</option>
          <option value="it">Italiano</option>
        </select>
      </div>
    </div>

    <div class="layout">
      <!-- Controls -->
      <div class="card">
        <div class="cardHeader">
          <b data-i18n="controlsTitle">Controles</b>
          <small>
            <span data-i18n="tipLabel">Tip:</span>
            <span data-i18n="tipText">probá</span> <span class="kbd">40×25</span>
            <span data-i18n="tipAnd">y</span> <span data-i18n="tipRoad">carretera</span> <span class="kbd">10</span>.
          </small>
        </div>
        <div class="cardBody">
          <!-- Difficulty + Presets -->
          <div class="grid">
            <div class="field">
              <label data-i18n="difficulty">Dificultad</label>
              <select id="difficulty">
                <option value="custom" data-i18n="diffCustom">Personalizada</option>
                <option value="easy" data-i18n="diffEasy">Fácil</option>
                <option value="medium" data-i18n="diffMedium">Media</option>
                <option value="hard" data-i18n="diffHard">Difícil</option>
              </select>
              <div class="hint" data-i18n="difficultyHint">Ajusta parámetros y (opcional) reduce callejones sin salida.</div>
            </div>

            <div class="field">
              <label data-i18n="preset">Preset</label>
              <select id="preset">
                <option value="none" data-i18n="presetNone">Ninguno</option>
                <option value="kdp10x8" data-i18n="presetKDP">Impresión 10×8 (KDP)</option>
              </select>
              <div class="hint" data-i18n="presetHint">Configura export a tamaño físico.</div>
            </div>
          </div>

          <div class="rowLine"></div>

          <!-- Maze params -->
          <div class="grid">
            <div class="field">
              <label data-i18n="cols">Columnas</label>
              <input id="cols" type="number" min="5" max="160" value="30" />
            </div>
            <div class="field">
              <label data-i18n="rows">Filas</label>
              <input id="rows" type="number" min="5" max="160" value="20" />
            </div>
            <div class="field">
              <label data-i18n="cell">Celda (px)</label>
              <input id="cell" type="number" min="10" max="80" value="24" />
              <div class="hint" data-i18n="cellHint">Afecta la vista previa (pantalla).</div>
            </div>
            <div class="field">
              <label data-i18n="road">Carretera (grosor)</label>
              <input id="road" type="number" min="2" max="40" value="10" />
              <div class="hint" data-i18n="roadHint">Para imprimir, 8–12 suele verse muy bien.</div>
            </div>

            <div class="field" style="grid-column:1 / -1">
              <label data-i18n="topPad">Margen superior (px)</label>
              <input id="topPad" type="number" min="0" max="420" value="90" />
              <div class="hint" data-i18n="topPadHint">Dejá espacio para título/consigna.</div>
            </div>

            <div class="field" style="grid-column:1 / -1">
              <label data-i18n="seed">Semilla (opcional)</label>
              <input id="seed" type="text" placeholder="ej: CAMIONES01" />
              <div class="hint" data-i18n="seedHint">Misma semilla ⇒ mismo laberinto.</div>
            </div>
          </div>

          <div class="rowLine"></div>

          <!-- Entry/Exit -->
          <div class="grid">
            <div class="field">
              <label data-i18n="entrySide">Entrada</label>
              <select id="entrySide">
                <option value="random" data-i18n="sideRandom">Aleatoria</option>
                <option value="left" data-i18n="sideLeft">Izquierda</option>
                <option value="right" data-i18n="sideRight">Derecha</option>
                <option value="top" data-i18n="sideTop">Arriba</option>
                <option value="bottom" data-i18n="sideBottom">Abajo</option>
              </select>
            </div>
            <div class="field">
              <label data-i18n="exitSide">Salida</label>
              <select id="exitSide">
                <option value="random" data-i18n="sideRandom">Aleatoria</option>
                <option value="left" data-i18n="sideLeft">Izquierda</option>
                <option value="right" data-i18n="sideRight">Derecha</option>
                <option value="top" data-i18n="sideTop">Arriba</option>
                <option value="bottom" data-i18n="sideBottom">Abajo</option>
              </select>
            </div>

            <div class="field" style="grid-column:1 / -1">
              <div class="switchLine">
                <div>
                  <b data-i18n="sameRow">Entrada y salida alineadas</b>
                  <div><span data-i18n="sameRowHint">Útil para “Fácil”.</span></div>
                </div>
                <div id="sameRowToggle" class="toggle" role="switch" aria-checked="false" tabindex="0"></div>
              </div>
            </div>
          </div>

          <div class="rowLine"></div>

          <!-- Export settings -->
          <div class="grid">
            <div class="field">
              <label data-i18n="exportDpi">DPI export</label>
              <select id="exportDpi">
                <option value="150">150</option>
                <option value="200">200</option>
                <option value="300" selected>300</option>
                <option value="600">600</option>
              </select>
              <div class="hint" data-i18n="dpiHint">300 DPI recomendado para KDP.</div>
            </div>

            <div class="field">
              <label data-i18n="topIn">Margen superior (in)</label>
              <input id="topIn" type="number" step="0.1" min="0" max="3" value="1.0" />
              <div class="hint" data-i18n="topInHint">Se usa en modo impresión 10×8.</div>
            </div>

            <div class="field" style="grid-column:1 / -1">
              <div class="switchLine">
                <div>
                  <b data-i18n="printMode">Modo impresión (10×8)</b>
                  <div><span data-i18n="printModeHint">Auto-ajusta export para tamaño físico.</span></div>
                </div>
                <div id="printToggle" class="toggle" role="switch" aria-checked="false" tabindex="0"></div>
              </div>
            </div>

            <div class="field" style="grid-column:1 / -1">
              <div class="switchLine">
                <div>
                  <b data-i18n="showSolution">Mostrar solución</b>
                  <div><span data-i18n="showSolutionHint">Overlay del camino correcto (solo vista previa y export opcional).</span></div>
                </div>
                <div id="solutionToggle" class="toggle" role="switch" aria-checked="false" tabindex="0"></div>
              </div>
            </div>
          </div>

          <div class="actions">
            <button id="gen" class="btnGood" data-i18n="btnGenerate">Generar</button>
            <button id="randSeed" class="btn2" data-i18n="btnRandomSeed">Semilla random</button>
          </div>

          <div class="actions3">
            <button id="svg" data-i18n="btnDownloadSVG">Descargar SVG</button>
            <button id="png" data-i18n="btnDownloadPNG">Descargar PNG</button>
            <button id="pdf" class="btnWarn" data-i18n="btnExportPDF">Exportar PDF</button>
          </div>

          <div class="actions3">
            <button id="share" class="btn2" data-i18n="btnCopyLink">Copiar link</button>
            <button id="reset" class="btn2" data-i18n="btnReset">Reset</button>
            <button id="about" class="btn2" data-i18n="btnAbout">About / License</button>
          </div>

          <div class="rowLine"></div>

          <!-- Batch -->
          <div class="grid3">
            <div class="field">
              <label data-i18n="batchCount">Batch</label>
              <input id="batchCount" type="number" min="2" max="200" value="20" />
              <div class="hint" data-i18n="batchHint">Descarga múltiple (tu navegador puede pedir confirmación).</div>
            </div>
            <div class="field">
              <label data-i18n="batchFormat">Formato</label>
              <select id="batchFormat">
                <option value="png">PNG</option>
                <option value="svg">SVG</option>
              </select>
            </div>
            <div class="field">
              <label>&nbsp;</label>
              <button id="batch" class="btnGood" data-i18n="btnBatch">Generar lote</button>
            </div>
          </div>

          <div id="warn" class="warn"></div>

          <div class="note" data-i18n="noteLocal">
            Los laberintos se generan en tu navegador. No guardamos datos ni usamos servidor.
          </div>

          <div class="mini" id="sizeInfo"></div>
        </div>
      </div>

      <!-- Canvas -->
      <div class="card">
        <div class="cardHeader">
          <b data-i18n="previewTitle">Vista previa</b>
          <small data-i18n="previewSubtitle">Entrada y salida se abren automáticamente. Exportá para impresión cuando te guste.</small>
        </div>
        <div class="canvasWrap">
          <canvas id="canvas" width="900" height="700" aria-label="Maze preview"></canvas>
        </div>
      </div>
    </div>

    <div class="footer" data-i18n="footer">
      © 2026 Alejandro Pena — AP MazeLab • Uso gratuito • Generación ilimitada
    </div>
  </div>

<script>
/* ===========================
   i18n (ES/EN/PT/IT)
   =========================== */
const i18n = {
  es: {
    pageTitle: "AP MazeLab — Free • Unlimited • Customizable",
    metaDescription: "AP MazeLab es una herramienta online, totalmente gratuita, para crear laberintos personalizables de forma ilimitada. Ajustá parámetros y exportá puzzles en SVG/PNG/PDF para libros, educación y proyectos creativos.",
    langLabel: "Idioma",
    tagline: "Free • Unlimited • Customizable maze generator",
    pillFreeStrong: "100% gratis",
    pillNoSignup: "sin registro",
    pillExport: "Export:",
    pillShare: "Compartí configs con un link",
    controlsTitle: "Controles",
    tipLabel: "Tip:",
    tipText: "probá",
    tipAnd: "y",
    tipRoad: "carretera",
    previewTitle: "Vista previa",
    previewSubtitle: "Entrada y salida se abren según configuración. Exportá cuando te guste.",
    difficulty: "Dificultad",
    diffCustom: "Personalizada",
    diffEasy: "Fácil",
    diffMedium: "Media",
    diffHard: "Difícil",
    difficultyHint: "Ajusta parámetros y (opcional) reduce callejones sin salida.",
    preset: "Preset",
    presetNone: "Ninguno",
    presetKDP: "Impresión 10×8 (KDP)",
    presetHint: "Configura export a tamaño físico.",
    cols: "Columnas",
    rows: "Filas",
    cell: "Celda (px)",
    cellHint: "Afecta la vista previa (pantalla).",
    road: "Carretera (grosor)",
    roadHint: "Para imprimir, 8–12 suele verse muy bien.",
    topPad: "Margen superior (px)",
    topPadHint: "Dejá espacio para título/consigna.",
    seed: "Semilla (opcional)",
    seedHint: "Misma semilla ⇒ mismo laberinto.",
    seedPlaceholder: "ej: CAMIONES01",
    entrySide: "Entrada",
    exitSide: "Salida",
    sideRandom: "Aleatoria",
    sideLeft: "Izquierda",
    sideRight: "Derecha",
    sideTop: "Arriba",
    sideBottom: "Abajo",
    sameRow: "Entrada y salida alineadas",
    sameRowHint: "Útil para “Fácil”.",
    exportDpi: "DPI export",
    dpiHint: "300 DPI recomendado para KDP.",
    topIn: "Margen superior (in)",
    topInHint: "Se usa en modo impresión 10×8.",
    printMode: "Modo impresión (10×8)",
    printModeHint: "Auto-ajusta export para tamaño físico.",
    showSolution: "Mostrar solución",
    showSolutionHint: "Overlay del camino correcto (vista previa + export opcional).",
    btnGenerate: "Generar",
    btnRandomSeed: "Semilla random",
    btnDownloadSVG: "Descargar SVG",
    btnDownloadPNG: "Descargar PNG",
    btnExportPDF: "Exportar PDF",
    btnCopyLink: "Copiar link",
    btnReset: "Reset",
    btnAbout: "About / License",
    batchCount: "Batch",
    batchHint: "Descarga múltiple (tu navegador puede pedir confirmación).",
    batchFormat: "Formato",
    btnBatch: "Generar lote",
    noteLocal: "Los laberintos se generan en tu navegador. No guardamos datos ni usamos servidor.",
    footer: "© 2026 Alejandro Pena — AP MazeLab • Uso gratuito • Generación ilimitada",
    linkCopied: "Link copiado al portapapeles ✅",
    heavyWarn: "Ojo: esta configuración es muy pesada y puede volverse lenta. Probá bajar columnas/filas o el tamaño de celda.",
    aboutText:
      "AP MazeLab es una herramienta 100% gratuita para generar laberintos ilimitados.\n\n" +
      "Privacidad: no guarda datos, no usa servidor.\n\n" +
      "Licencia sugerida para el código: MIT.\n" +
      "El contenido generado (laberintos) puede usarse libremente en proyectos personales/comerciales.\n\n" +
      "© 2026 Alejandro Pena",
    pdfHint:
      "Se abrirá un SVG listo para imprimir.\nEn esa pestaña: Imprimir → Guardar como PDF.\nTip: desactivá encabezados/pies y ajustá escala a 100%."
  },
  en: {
    pageTitle: "AP MazeLab — Free • Unlimited • Customizable",
    metaDescription: "AP MazeLab is a totally free online tool to generate unlimited customizable mazes. Easily tweak parameters and export high-quality puzzles as SVG/PNG/PDF for books, education, and creative projects.",
    langLabel: "Language",
    tagline: "Free • Unlimited • Customizable maze generator",
    pillFreeStrong: "100% free",
    pillNoSignup: "no sign-up",
    pillExport: "Export:",
    pillShare: "Share settings with a link",
    controlsTitle: "Controls",
    tipLabel: "Tip:",
    tipText: "try",
    tipAnd: "and",
    tipRoad: "road",
    previewTitle: "Preview",
    previewSubtitle: "Entry/exit open based on your settings. Export when you like the result.",
    difficulty: "Difficulty",
    diffCustom: "Custom",
    diffEasy: "Easy",
    diffMedium: "Medium",
    diffHard: "Hard",
    difficultyHint: "Adjust parameters and (optional) reduce dead ends.",
    preset: "Preset",
    presetNone: "None",
    presetKDP: "Print 10×8 (KDP)",
    presetHint: "Exports at a physical print size.",
    cols: "Columns",
    rows: "Rows",
    cell: "Cell (px)",
    cellHint: "Affects on-screen preview.",
    road: "Road thickness",
    roadHint: "For print, 8–12 usually looks great.",
    topPad: "Top margin (px)",
    topPadHint: "Leave space for title/instructions.",
    seed: "Seed (optional)",
    seedHint: "Same seed ⇒ same maze.",
    seedPlaceholder: "e.g.: TRUCKS01",
    entrySide: "Entry",
    exitSide: "Exit",
    sideRandom: "Random",
    sideLeft: "Left",
    sideRight: "Right",
    sideTop: "Top",
    sideBottom: "Bottom",
    sameRow: "Align entry and exit",
    sameRowHint: "Useful for Easy.",
    exportDpi: "Export DPI",
    dpiHint: "300 DPI recommended for KDP.",
    topIn: "Top margin (in)",
    topInHint: "Used in 10×8 print mode.",
    printMode: "Print mode (10×8)",
    printModeHint: "Auto-fits export to physical size.",
    showSolution: "Show solution",
    showSolutionHint: "Correct path overlay (preview + optional export).",
    btnGenerate: "Generate",
    btnRandomSeed: "Random seed",
    btnDownloadSVG: "Download SVG",
    btnDownloadPNG: "Download PNG",
    btnExportPDF: "Export PDF",
    btnCopyLink: "Copy link",
    btnReset: "Reset",
    btnAbout: "About / License",
    batchCount: "Batch",
    batchHint: "Multiple downloads (your browser may ask).",
    batchFormat: "Format",
    btnBatch: "Batch generate",
    noteLocal: "Mazes are generated in your browser. No data is stored and no server is used.",
    footer: "© 2026 Alejandro Pena — AP MazeLab • Free to use • Unlimited generation",
    linkCopied: "Link copied to clipboard ✅",
    heavyWarn: "Heads up: this configuration is heavy and may be slow. Try fewer rows/columns or a smaller cell size.",
    aboutText:
      "AP MazeLab is a 100% free tool to generate unlimited mazes.\n\n" +
      "Privacy: no data stored, no server used.\n\n" +
      "Suggested code license: MIT.\n" +
      "Generated content (mazes) can be used freely for personal/commercial projects.\n\n" +
      "© 2026 Alejandro Pena",
    pdfHint:
      "An SVG ready for printing will open.\nIn that tab: Print → Save as PDF.\nTip: disable headers/footers and keep scale at 100%."
  },
  pt: {
    pageTitle: "AP MazeLab — Free • Unlimited • Customizable",
    metaDescription: "AP MazeLab é uma ferramenta online totalmente gratuita para gerar labirintos personalizáveis de forma ilimitada. Ajuste parâmetros facilmente e exporte puzzles em SVG/PNG/PDF para livros, educação e projetos criativos.",
    langLabel: "Idioma",
    tagline: "Free • Unlimited • Customizable maze generator",
    pillFreeStrong: "100% grátis",
    pillNoSignup: "sem cadastro",
    pillExport: "Exportar:",
    pillShare: "Compartilhe as configs por link",
    controlsTitle: "Controles",
    tipLabel: "Dica:",
    tipText: "tente",
    tipAnd: "e",
    tipRoad: "estrada",
    previewTitle: "Pré-visualização",
    previewSubtitle: "Entrada/saída abrem conforme as configurações. Exporte quando gostar do resultado.",
    difficulty: "Dificuldade",
    diffCustom: "Personalizada",
    diffEasy: "Fácil",
    diffMedium: "Média",
    diffHard: "Difícil",
    difficultyHint: "Ajuste parâmetros e (opcional) reduza becos sem saída.",
    preset: "Preset",
    presetNone: "Nenhum",
    presetKDP: "Impressão 10×8 (KDP)",
    presetHint: "Exporta em tamanho físico.",
    cols: "Colunas",
    rows: "Linhas",
    cell: "Célula (px)",
    cellHint: "Afeta a pré-visualização.",
    road: "Espessura da estrada",
    roadHint: "Para impressão, 8–12 costuma ficar ótimo.",
    topPad: "Margem superior (px)",
    topPadHint: "Deixe espaço para título/instruções.",
    seed: "Seed (opcional)",
    seedHint: "Mesma seed ⇒ mesmo labirinto.",
    seedPlaceholder: "ex.: CAMINHOES01",
    entrySide: "Entrada",
    exitSide: "Saída",
    sideRandom: "Aleatória",
    sideLeft: "Esquerda",
    sideRight: "Direita",
    sideTop: "Topo",
    sideBottom: "Base",
    sameRow: "Alinhar entrada e saída",
    sameRowHint: "Útil para Fácil.",
    exportDpi: "DPI export",
    dpiHint: "300 DPI recomendado para KDP.",
    topIn: "Margem superior (in)",
    topInHint: "Usado no modo 10×8.",
    printMode: "Modo impressão (10×8)",
    printModeHint: "Ajusta export para tamanho físico.",
    showSolution: "Mostrar solução",
    showSolutionHint: "Caminho correto (prévia + export opcional).",
    btnGenerate: "Gerar",
    btnRandomSeed: "Seed aleatória",
    btnDownloadSVG: "Baixar SVG",
    btnDownloadPNG: "Baixar PNG",
    btnExportPDF: "Exportar PDF",
    btnCopyLink: "Copiar link",
    btnReset: "Reset",
    btnAbout: "About / License",
    batchCount: "Batch",
    batchHint: "Vários downloads (o navegador pode perguntar).",
    batchFormat: "Formato",
    btnBatch: "Gerar lote",
    noteLocal: "Os labirintos são gerados no seu navegador. Não salvamos dados e não usamos servidor.",
    footer: "© 2026 Alejandro Pena — AP MazeLab • Uso gratuito • Geração ilimitada",
    linkCopied: "Link copiado ✅",
    heavyWarn: "Atenção: esta configuração é pesada e pode ficar lenta. Tente menos linhas/colunas ou uma célula menor.",
    aboutText:
      "AP MazeLab é uma ferramenta 100% gratuita para gerar labirintos ilimitados.\n\n" +
      "Privacidade: não salva dados, não usa servidor.\n\n" +
      "Licença sugerida do código: MIT.\n" +
      "O conteúdo gerado (labirintos) pode ser usado livremente em projetos pessoais/comerciais.\n\n" +
      "© 2026 Alejandro Pena",
    pdfHint:
      "Um SVG pronto para impressão será aberto.\nNa nova aba: Imprimir → Salvar como PDF.\nDica: desative cabeçalhos/rodapés e mantenha escala 100%."
  },
  it: {
    pageTitle: "AP MazeLab — Free • Unlimited • Customizable",
    metaDescription: "AP MazeLab è uno strumento online totalmente gratuito per generare labirinti personalizzabili in modo illimitato. Regola facilmente i parametri ed esporta puzzle di alta qualità in SVG/PNG/PDF per libri, educazione e progetti creativi.",
    langLabel: "Lingua",
    tagline: "Free • Unlimited • Customizable maze generator",
    pillFreeStrong: "100% gratis",
    pillNoSignup: "senza registrazione",
    pillExport: "Esporta:",
    pillShare: "Condividi le impostazioni con un link",
    controlsTitle: "Controlli",
    tipLabel: "Suggerimento:",
    tipText: "prova",
    tipAnd: "e",
    tipRoad: "strada",
    previewTitle: "Anteprima",
    previewSubtitle: "Ingresso/uscita si aprono in base alle impostazioni. Esporta quando ti piace.",
    difficulty: "Difficoltà",
    diffCustom: "Personalizzata",
    diffEasy: "Facile",
    diffMedium: "Media",
    diffHard: "Difficile",
    difficultyHint: "Regola parametri e (opzionale) riduci i vicoli ciechi.",
    preset: "Preset",
    presetNone: "Nessuno",
    presetKDP: "Stampa 10×8 (KDP)",
    presetHint: "Esporta in dimensione fisica.",
    cols: "Colonne",
    rows: "Righe",
    cell: "Cella (px)",
    cellHint: "Influisce sull'anteprima.",
    road: "Spessore strada",
    roadHint: "Per stampa, 8–12 di solito è ottimo.",
    topPad: "Margine superiore (px)",
    topPadHint: "Lascia spazio per titolo/istruzioni.",
    seed: "Seed (opzionale)",
    seedHint: "Stessa seed ⇒ stesso labirinto.",
    seedPlaceholder: "es.: CAMION01",
    entrySide: "Ingresso",
    exitSide: "Uscita",
    sideRandom: "Casuale",
    sideLeft: "Sinistra",
    sideRight: "Destra",
    sideTop: "Sopra",
    sideBottom: "Sotto",
    sameRow: "Allinea ingresso e uscita",
    sameRowHint: "Utile per Facile.",
    exportDpi: "DPI export",
    dpiHint: "300 DPI consigliato per KDP.",
    topIn: "Margine superiore (in)",
    topInHint: "Usato in modalità 10×8.",
    printMode: "Modalità stampa (10×8)",
    printModeHint: "Adatta export alla dimensione fisica.",
    showSolution: "Mostra soluzione",
    showSolutionHint: "Percorso corretto (anteprima + export opzionale).",
    btnGenerate: "Genera",
    btnRandomSeed: "Seed casuale",
    btnDownloadSVG: "Scarica SVG",
    btnDownloadPNG: "Scarica PNG",
    btnExportPDF: "Esporta PDF",
    btnCopyLink: "Copia link",
    btnReset: "Reset",
    btnAbout: "About / License",
    batchCount: "Batch",
    batchHint: "Download multipli (il browser può chiedere).",
    batchFormat: "Formato",
    btnBatch: "Genera lotto",
    noteLocal: "I labirinti vengono generati nel tuo browser. Nessun dato viene salvato e non viene usato alcun server.",
    footer: "© 2026 Alejandro Pena — AP MazeLab • Uso gratuito • Generazione illimitata",
    linkCopied: "Link copiato ✅",
    heavyWarn: "Attenzione: questa configurazione è pesante e potrebbe essere lenta. Prova meno righe/colonne o una cella più piccola.",
    aboutText:
      "AP MazeLab è uno strumento 100% gratuito per generare labirinti illimitati.\n\n" +
      "Privacy: nessun dato salvato, nessun server.\n\n" +
      "Licenza suggerita per il codice: MIT.\n" +
      "Il contenuto generato (labirinti) può essere usato liberamente per progetti personali/commerciali.\n\n" +
      "© 2026 Alejandro Pena",
    pdfHint:
      "Si aprirà un SVG pronto per la stampa.\nNella nuova scheda: Stampa → Salva come PDF.\nSuggerimento: disattiva intestazioni/piè di pagina e mantieni scala 100%."
  }
};

let currentLang = "es";

/* ===========================
   Helpers
   =========================== */
function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }
function toInt(v, fallback){ const n=parseInt(v,10); return Number.isFinite(n)?n:fallback; }
function toFloat(v, fallback){ const n=parseFloat(v); return Number.isFinite(n)?n:fallback; }

function detectLang() {
  const sp = new URLSearchParams(window.location.search);
  const fromUrl = (sp.get("lang") || "").toLowerCase();
  const fromStorage = (localStorage.getItem("apml_lang") || "").toLowerCase();
  const nav = (navigator.language || "es").slice(0,2).toLowerCase();
  const pick = fromUrl || fromStorage || nav || "es";
  return i18n[pick] ? pick : "es";
}

function applyLang(lang) {
  currentLang = i18n[lang] ? lang : "es";
  localStorage.setItem("apml_lang", currentLang);

  const sel = document.getElementById("lang");
  if (sel) sel.value = currentLang;
  const label = document.getElementById("langLabel");
  if (label) label.textContent = i18n[currentLang].langLabel;

  document.querySelectorAll("[data-i18n]").forEach(el => {
    const key = el.getAttribute("data-i18n");
    if (i18n[currentLang][key]) el.textContent = i18n[currentLang][key];
  });

  const seedInput = document.getElementById("seed");
  if (seedInput) seedInput.placeholder = i18n[currentLang].seedPlaceholder;

  document.title = i18n[currentLang].pageTitle;
  const meta = document.querySelector('meta[name="description"]');
  if (meta) meta.setAttribute("content", i18n[currentLang].metaDescription);
}

function downloadText(filename, text, mime) {
  const blob = new Blob([text], {type: mime});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  setTimeout(()=>URL.revokeObjectURL(url), 2500);
}

function downloadBlob(filename, blob) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  setTimeout(()=>URL.revokeObjectURL(url), 2500);
}

function setWarn(msg, kind="warn"){
  const warnEl = document.getElementById("warn");
  warnEl.classList.remove("ok");
  warnEl.style.display = "block";
  warnEl.textContent = msg;
  if (kind === "ok") warnEl.classList.add("ok");
  if (kind === "autoHide") {
    warnEl.classList.add("ok");
    setTimeout(()=>{ warnEl.style.display="none"; }, 1600);
  }
}
function hideWarn(){
  const warnEl = document.getElementById("warn");
  warnEl.style.display = "none";
  warnEl.textContent = "";
}

function setToggle(el, on){
  el.classList.toggle("on", !!on);
  el.setAttribute("aria-checked", !!on ? "true" : "false");
}
function getToggle(el){ return el.classList.contains("on"); }

function buildShareURL(params){
  const u = new URL(window.location.href);
  for (const [k,v] of Object.entries(params)) {
    if (v === "" || v === null || v === undefined) u.searchParams.delete(k);
    else u.searchParams.set(k, String(v));
  }
  return u.toString();
}

/* ===========================
   RNG with seed (xmur3 + sfc32)
   =========================== */
function xmur3(str) {
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function() {
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    return (h ^= h >>> 16) >>> 0;
  };
}
function sfc32(a, b, c, d) {
  return function() {
    a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;
    let t = (a + b) | 0;
    a = b ^ (b >>> 9);
    b = (c + (c << 3)) | 0;
    c = (c << 21) | (c >>> 11);
    d = (d + 1) | 0;
    t = (t + d) | 0;
    c = (c + t) | 0;
    return (t >>> 0) / 4294967296;
  };
}
function makeRng(seedStr) {
  if (!seedStr) return Math.random;
  const seed = xmur3(seedStr);
  return sfc32(seed(), seed(), seed(), seed());
}

/* ===========================
   Maze generation (DFS)
   grid[y][x].walls: [N,E,S,W]
   =========================== */
function generateMaze(cols, rows, rng) {
  const dx = [0,1,0,-1];
  const dy = [-1,0,1,0];
  const opposite = [2,3,0,1];

  const grid = Array.from({length: rows}, () =>
    Array.from({length: cols}, () => ({ walls: [true,true,true,true], visited:false }))
  );

  const stack = [];
  let cx = Math.floor(rng()*cols);
  let cy = Math.floor(rng()*rows);

  grid[cy][cx].visited = true;
  stack.push([cx,cy]);

  while (stack.length) {
    const [x,y] = stack[stack.length-1];

    const neighbors = [];
    for (let dir=0; dir<4; dir++) {
      const nx = x + dx[dir];
      const ny = y + dy[dir];
      if (nx>=0 && nx<cols && ny>=0 && ny<rows && !grid[ny][nx].visited) {
        neighbors.push([dir,nx,ny]);
      }
    }

    if (!neighbors.length) { stack.pop(); continue; }

    const [dir,nx,ny] = neighbors[Math.floor(rng()*neighbors.length)];
    grid[y][x].walls[dir] = false;
    grid[ny][nx].walls[opposite[dir]] = false;

    grid[ny][nx].visited = true;
    stack.push([nx,ny]);
  }

  for (let r=0;r<rows;r++) for (let c=0;c<cols;c++) grid[r][c].visited=false;
  return grid;
}

/* ===========================
   Optional: "braid" (reduce dead-ends)
   factor: 0..1 (higher => fewer dead ends, easier)
   =========================== */
function braidMaze(grid, rng, factor){
  if (factor <= 0) return;
  const rows = grid.length;
  const cols = grid[0].length;
  const dx = [0,1,0,-1];
  const dy = [-1,0,1,0];
  const opposite = [2,3,0,1];

  function wallCount(cell){ return cell.walls.reduce((a,b)=>a+(b?1:0),0); }

  const deadEnds = [];
  for (let y=0;y<rows;y++){
    for (let x=0;x<cols;x++){
      if (wallCount(grid[y][x]) === 3) deadEnds.push([x,y]);
    }
  }

  // shuffle
  for (let i = deadEnds.length - 1; i > 0; i--) {
    const j = Math.floor(rng()*(i+1));
    [deadEnds[i], deadEnds[j]] = [deadEnds[j], deadEnds[i]];
  }

  const toOpen = Math.floor(deadEnds.length * factor);
  for (let i=0;i<toOpen;i++){
    const [x,y] = deadEnds[i];
    const options = [];
    for (let dir=0; dir<4; dir++){
      const nx = x + dx[dir], ny = y + dy[dir];
      if (nx>=0 && nx<cols && ny>=0 && ny<rows && grid[y][x].walls[dir]) {
        options.push([dir,nx,ny]);
      }
    }
    if (!options.length) continue;
    const [dir,nx,ny] = options[Math.floor(rng()*options.length)];
    grid[y][x].walls[dir] = false;
    grid[ny][nx].walls[opposite[dir]] = false;
  }
}

/* ===========================
   Entry/Exit selection + store
   =========================== */
const canvas = document.getElementById('canvas');
const sizeInfo = document.getElementById('sizeInfo');

let lastGrid = null;
let lastParams = null;

let lastEntry = null; // {side, x, y} where x,y are cell coords inside grid
let lastExit  = null;

function pickSide(rng, side){
  if (side !== "random") return side;
  const sides = ["left","right","top","bottom"];
  return sides[Math.floor(rng()*sides.length)];
}

function chooseEntryExit(cols, rows, rng, entrySideUI, exitSideUI, sameRow){
  const entrySide = pickSide(rng, entrySideUI);
  const exitSide = pickSide(rng, exitSideUI);

  let ex=0, ey=0, ox=0, oy=0;

  // helper for picking positions
  const pickRow = ()=> Math.floor(rng()*rows);
  const pickCol = ()=> Math.floor(rng()*cols);

  // entry point cell inside grid
  if (entrySide === "left") { ex=0; ey=pickRow(); }
  if (entrySide === "right"){ ex=cols-1; ey=pickRow(); }
  if (entrySide === "top")  { ex=pickCol(); ey=0; }
  if (entrySide === "bottom"){ ex=pickCol(); ey=rows-1; }

  // exit point cell inside grid
  if (exitSide === "left") { ox=0; oy=pickRow(); }
  if (exitSide === "right"){ ox=cols-1; oy=pickRow(); }
  if (exitSide === "top")  { ox=pickCol(); oy=0; }
  if (exitSide === "bottom"){ ox=pickCol(); oy=rows-1; }

  // optional alignment: if both open on vertical sides, align row; if horizontal sides, align col
  if (sameRow) {
    if ((entrySide === "left" || entrySide === "right") && (exitSide === "left" || exitSide === "right")) {
      oy = ey;
    }
    if ((entrySide === "top" || entrySide === "bottom") && (exitSide === "top" || exitSide === "bottom")) {
      ox = ex;
    }
  }

  return {
    entry: { side: entrySide, x: ex, y: ey },
    exit:  { side: exitSide,  x: ox, y: oy }
  };
}

function openBoundary(grid, point){
  // remove the boundary wall for entry/exit cell based on side
  const {x,y,side} = point;
  const cell = grid[y][x];
  if (side === "left") cell.walls[3] = false;
  if (side === "right") cell.walls[1] = false;
  if (side === "top") cell.walls[0] = false;
  if (side === "bottom") cell.walls[2] = false;
}

/* ===========================
   Solve path (BFS)
   returns array of cells [{x,y},...]
   =========================== */
function solveMaze(grid, entry, exit){
  const rows = grid.length, cols = grid[0].length;
  const q = [];
  const visited = Array.from({length: rows}, ()=>Array(cols).fill(false));
  const prev = Array.from({length: rows}, ()=>Array(cols).fill(null));

  q.push([entry.x, entry.y]);
  visited[entry.y][entry.x] = true;

  const dirs = [
    {dir:0, dx:0, dy:-1}, // N
    {dir:1, dx:1, dy:0},  // E
    {dir:2, dx:0, dy:1},  // S
    {dir:3, dx:-1, dy:0}, // W
  ];

  while (q.length){
    const [x,y] = q.shift();
    if (x === exit.x && y === exit.y) break;

    for (const d of dirs){
      const nx = x + d.dx, ny = y + d.dy;
      if (nx<0||nx>=cols||ny<0||ny>=rows) continue;
      // move allowed if no wall in that dir
      if (grid[y][x].walls[d.dir]) continue;
      if (visited[ny][nx]) continue;
      visited[ny][nx] = true;
      prev[ny][nx] = {x,y};
      q.push([nx,ny]);
    }
  }

  if (!visited[exit.y][exit.x]) return null;

  const path = [];
  let cur = {x: exit.x, y: exit.y};
  while (cur){
    path.push(cur);
    cur = prev[cur.y][cur.x];
  }
  path.reverse();
  return path;
}

/* ===========================
   Draw maze (thick walls)
   =========================== */
function drawMazeToCanvas(targetCanvas, grid, cell, road, topPad, showSolution){
  const ctx = targetCanvas.getContext('2d');
  const rows = grid.length;
  const cols = grid[0].length;

  const w = cols * cell;
  const h = rows * cell + topPad;

  targetCanvas.width = Math.max(2, Math.floor(w + 2));
  targetCanvas.height = Math.max(2, Math.floor(h + 2));

  ctx.clearRect(0,0,targetCanvas.width,targetCanvas.height);
  ctx.fillStyle = "#fff";
  ctx.fillRect(0,0,targetCanvas.width,targetCanvas.height);

  // reserved top area guideline
  if (topPad > 0) {
    ctx.strokeStyle = "#eee";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, topPad+0.5);
    ctx.lineTo(targetCanvas.width, topPad+0.5);
    ctx.stroke();
  }

  const ox = 1;
  const oy = topPad + 1;

  // walls
  ctx.strokeStyle = "#111";
  ctx.lineCap = "square";
  ctx.lineWidth = Math.max(2, Math.floor(road));

  for (let y=0; y<rows; y++) {
    for (let x=0; x<cols; x++) {
      const c = grid[y][x];
      const x0 = ox + x*cell;
      const y0 = oy + y*cell;
      const x1 = x0 + cell;
      const y1 = y0 + cell;

      if (c.walls[0]) { ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y0); ctx.stroke(); }
      if (c.walls[1]) { ctx.beginPath(); ctx.moveTo(x1,y0); ctx.lineTo(x1,y1); ctx.stroke(); }
      if (c.walls[2]) { ctx.beginPath(); ctx.moveTo(x0,y1); ctx.lineTo(x1,y1); ctx.stroke(); }
      if (c.walls[3]) { ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x0,y1); ctx.stroke(); }
    }
  }

  // solution overlay
  if (showSolution && lastEntry && lastExit){
    const path = solveMaze(grid, lastEntry, lastExit);
    if (path && path.length > 1){
      ctx.strokeStyle = "rgba(6,182,212,.65)";
      ctx.lineWidth = Math.max(2, Math.floor(cell * 0.22));
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.beginPath();
      for (let i=0;i<path.length;i++){
        const p = path[i];
        const cx = ox + p.x*cell + cell/2;
        const cy = oy + p.y*cell + cell/2;
        if (i===0) ctx.moveTo(cx,cy);
        else ctx.lineTo(cx,cy);
      }
      ctx.stroke();
    }
  }
}

/* ===========================
   SVG export (with openings + optional solution path)
   Supports printMode: set physical size 10x8 using DPI
   =========================== */
function mazeToSVG(grid, opts){
  const {cell, road, topPad, showSolution, printMode, dpi, topIn} = opts;
  const rows = grid.length;
  const cols = grid[0].length;

  // export canvas size in px
  let Wpx = cols*cell + 2;
  let Hpx = rows*cell + topPad + 2;

  // Print mode: 10x8 inches landscape
  let widthAttr = `${Wpx}`;
  let heightAttr = `${Hpx}`;
  let viewBox = `0 0 ${Wpx} ${Hpx}`;

  if (printMode){
    const wIn = 10, hIn = 8;
    Wpx = Math.round(wIn * dpi);
    Hpx = Math.round(hIn * dpi);
    const topPadPx = Math.round(topIn * dpi);

    // compute cell to fit grid
    const cellFit = Math.floor(Math.min((Wpx-2)/cols, (Hpx-topPadPx-2)/rows));
    const c = Math.max(2, cellFit);
    const r = Math.max(2, Math.round(road * (c / cell))); // scale road from preview cell
    const tp = Math.max(0, topPadPx);

    // override for print export
    return mazeToSVG(grid, {
      cell: c,
      road: r,
      topPad: tp,
      showSolution,
      printMode: false, // already applied
      dpi, topIn
    }).replace(
      /<svg([^>]+)width="[^"]+" height="[^"]+"/,
      `<svg$1width="${wIn}in" height="${hIn}in"`
    );
  }

  const ox=1, oy=topPad+1;

  const paths = [];
  const line = (x1,y1,x2,y2)=> paths.push(`<path d="M ${x1} ${y1} L ${x2} ${y2}" />`);

  // walls
  for (let y=0; y<rows; y++) {
    for (let x=0; x<cols; x++) {
      const c = grid[y][x];
      const x0 = ox + x*cell;
      const y0 = oy + y*cell;
      const x1 = x0 + cell;
      const y1 = y0 + cell;

      if (c.walls[0]) line(x0,y0,x1,y0);
      if (c.walls[1]) line(x1,y0,x1,y1);
      if (c.walls[2]) line(x0,y1,x1,y1);
      if (c.walls[3]) line(x0,y0,x0,y1);
    }
  }

  // openings (white strokes to "erase")
  const eraseW = Math.max(road+2, road*1.3);
  let openings = "";
  if (lastEntry){
    const {x,y,side} = lastEntry;
    const x0 = ox + x*cell;
    const y0 = oy + y*cell;
    const x1 = x0 + cell;
    const y1 = y0 + cell;
    if (side==="left") openings += `<path d="M ${x0} ${y0} L ${x0} ${y1}" />\n`;
    if (side==="right") openings += `<path d="M ${x1} ${y0} L ${x1} ${y1}" />\n`;
    if (side==="top") openings += `<path d="M ${x0} ${y0} L ${x1} ${y0}" />\n`;
    if (side==="bottom") openings += `<path d="M ${x0} ${y1} L ${x1} ${y1}" />\n`;
  }
  if (lastExit){
    const {x,y,side} = lastExit;
    const x0 = ox + x*cell;
    const y0 = oy + y*cell;
    const x1 = x0 + cell;
    const y1 = y0 + cell;
    if (side==="left") openings += `<path d="M ${x0} ${y0} L ${x0} ${y1}" />\n`;
    if (side==="right") openings += `<path d="M ${x1} ${y0} L ${x1} ${y1}" />\n`;
    if (side==="top") openings += `<path d="M ${x0} ${y0} L ${x1} ${y0}" />\n`;
    if (side==="bottom") openings += `<path d="M ${x0} ${y1} L ${x1} ${y1}" />\n`;
  }

  // solution path
  let solSvg = "";
  if (showSolution && lastEntry && lastExit){
    const path = solveMaze(grid, lastEntry, lastExit);
    if (path && path.length > 1){
      const d = path.map((p, i)=>{
        const cx = ox + p.x*cell + cell/2;
        const cy = oy + p.y*cell + cell/2;
        return `${i===0 ? "M" : "L"} ${cx} ${cy}`;
      }).join(" ");
      const sw = Math.max(2, Math.floor(cell*0.22));
      solSvg = `<path d="${d}" />`;
      solSvg = `<g fill="none" stroke="rgba(6,182,212,.65)" stroke-width="${sw}" stroke-linecap="round" stroke-linejoin="round">${solSvg}</g>`;
    }
  }

  return `<svg xmlns="http://www.w3.org/2000/svg" width="${widthAttr}" height="${heightAttr}" viewBox="${viewBox}">
  <rect width="100%" height="100%" fill="#fff"/>
  ${topPad>0 ? `<line x1="0" y1="${topPad+0.5}" x2="${Wpx}" y2="${topPad+0.5}" stroke="#eee" stroke-width="1"/>` : ""}
  <g fill="none" stroke="#111" stroke-width="${road}" stroke-linecap="square">
    ${paths.join("\n    ")}
  </g>
  <g fill="none" stroke="#fff" stroke-width="${eraseW}" stroke-linecap="square">
    ${openings}
  </g>
  ${solSvg}
</svg>`;
}

/* ===========================
   Export PNG (supports print mode 10x8 at DPI)
   =========================== */
function exportPNG(){
  if (!lastGrid) regenerate();

  const p = lastParams || readParamsFromUI();
  const printMode = getToggle(document.getElementById("printToggle"));
  const dpi = toInt(document.getElementById("exportDpi").value, 300);
  const topIn = clamp(toFloat(document.getElementById("topIn").value, 1.0), 0, 3);
  const showSol = getToggle(document.getElementById("solutionToggle"));

  // on-screen mode export
  if (!printMode){
    canvas.toBlob((blob)=>{
      downloadBlob('ap-mazelab-maze.png', blob);
    }, "image/png");
    return;
  }

  // print mode export: 10x8 inches
  const wIn = 10, hIn = 8;
  const Wpx = Math.round(wIn * dpi);
  const Hpx = Math.round(hIn * dpi);
  const topPadPx = Math.round(topIn * dpi);

  const cols = p.cols, rows = p.rows;
  const cellFit = Math.floor(Math.min((Wpx-2)/cols, (Hpx-topPadPx-2)/rows));
  const cell = Math.max(2, cellFit);

  // scale road relative to preview cell
  const road = Math.max(2, Math.round(p.road * (cell / p.cell)));

  const off = document.createElement("canvas");
  drawMazeToCanvas(off, lastGrid, cell, road, topPadPx, showSol);

  off.toBlob((blob)=>{
    downloadBlob(`ap-mazelab-10x8-${dpi}dpi.png`, blob);
  }, "image/png");
}

/* ===========================
   PDF export (open SVG and let user print to PDF)
   =========================== */
function exportPDF(){
  if (!lastGrid) regenerate();

  const p = lastParams || readParamsFromUI();
  const printMode = getToggle(document.getElementById("printToggle"));
  const dpi = toInt(document.getElementById("exportDpi").value, 300);
  const topIn = clamp(toFloat(document.getElementById("topIn").value, 1.0), 0, 3);
  const showSol = getToggle(document.getElementById("solutionToggle"));

  // We open SVG in new tab with correct physical sizing when printMode is on
  const svg = mazeToSVG(lastGrid, {
    cell: p.cell, road: p.road, topPad: p.topPad,
    showSolution: showSol,
    printMode,
    dpi,
    topIn
  });

  alert(i18n[currentLang].pdfHint);

  const blob = new Blob([svg], {type:"image/svg+xml"});
  const url = URL.createObjectURL(blob);
  const w = window.open(url, "_blank");
  // do not auto-print (some browsers block); user prints manually.
  setTimeout(()=>URL.revokeObjectURL(url), 10_000);
}

/* ===========================
   Read params + presets + difficulty
   =========================== */
function readParamsFromUI() {
  const cols = clamp(toInt(document.getElementById('cols').value, 30), 5, 160);
  const rows = clamp(toInt(document.getElementById('rows').value, 20), 5, 160);
  const cell = clamp(toInt(document.getElementById('cell').value, 24), 10, 80);
  const road = clamp(toInt(document.getElementById('road').value, 10), 2, 40);
  const topPad = clamp(toInt(document.getElementById('topPad').value, 90), 0, 420);
  const seed = (document.getElementById('seed').value || "").trim();
  const entrySide = document.getElementById("entrySide").value;
  const exitSide  = document.getElementById("exitSide").value;
  const sameRow = getToggle(document.getElementById("sameRowToggle"));
  const showSolution = getToggle(document.getElementById("solutionToggle"));

  // write back clamped
  document.getElementById('cols').value = cols;
  document.getElementById('rows').value = rows;
  document.getElementById('cell').value = cell;
  document.getElementById('road').value = road;
  document.getElementById('topPad').value = topPad;

  return { cols, rows, cell, road, topPad, seed, entrySide, exitSide, sameRow, showSolution };
}

function applyDifficultyPreset(mode){
  // also sets braid factor
  if (mode === "easy"){
    document.getElementById("cols").value = 28;
    document.getElementById("rows").value = 18;
    document.getElementById("cell").value = 26;
    document.getElementById("road").value = 12;
    document.getElementById("topPad").value = 110;
    setToggle(document.getElementById("sameRowToggle"), true);
  } else if (mode === "medium"){
    document.getElementById("cols").value = 40;
    document.getElementById("rows").value = 25;
    document.getElementById("cell").value = 22;
    document.getElementById("road").value = 10;
    document.getElementById("topPad").value = 90;
    setToggle(document.getElementById("sameRowToggle"), false);
  } else if (mode === "hard"){
    document.getElementById("cols").value = 60;
    document.getElementById("rows").value = 38;
    document.getElementById("cell").value = 16;
    document.getElementById("road").value = 8;
    document.getElementById("topPad").value = 80;
    setToggle(document.getElementById("sameRowToggle"), false);
  }
}

function braidFactorFromDifficulty(mode){
  if (mode === "easy") return 0.28;
  if (mode === "medium") return 0.10;
  if (mode === "hard") return 0.00;
  return 0.00; // custom default
}

function applyPreset(preset){
  if (preset === "kdp10x8"){
    setToggle(document.getElementById("printToggle"), true);
    document.getElementById("exportDpi").value = "300";
    document.getElementById("topIn").value = "1.0";
  }
}

function maybeWarn(cols, rows, cell){
  const px = cols * rows * cell * cell;
  if (px > 60_000_000) {
    setWarn(i18n[currentLang].heavyWarn, "warn");
  } else {
    hideWarn();
  }
}

function updateSizeInfo(){
  const p = lastParams || readParamsFromUI();
  const printMode = getToggle(document.getElementById("printToggle"));
  const dpi = toInt(document.getElementById("exportDpi").value, 300);
  const topIn = clamp(toFloat(document.getElementById("topIn").value, 1.0), 0, 3);

  if (!printMode){
    const W = p.cols*p.cell + 2;
    const H = p.rows*p.cell + p.topPad + 2;
    sizeInfo.textContent = `Preview px: ${W}×${H}. Export: SVG/PNG/PDF.`;
  } else {
    const W = Math.round(10*dpi);
    const H = Math.round(8*dpi);
    const topPadPx = Math.round(topIn*dpi);
    sizeInfo.textContent = `Print export: 10×8 in @ ${dpi} DPI → ${W}×${H} px. Top margin: ${topIn} in (${topPadPx}px).`;
  }
}

/* ===========================
   Regenerate
   =========================== */
function regenerate() {
  const diff = document.getElementById("difficulty").value;
  const braidFactor = braidFactorFromDifficulty(diff);

  const p = readParamsFromUI();
  maybeWarn(p.cols, p.rows, p.cell);

  const rngMaze = makeRng(p.seed || String(Date.now()));
  lastGrid = generateMaze(p.cols, p.rows, rngMaze);

  // braid (reduce dead-ends) based on difficulty
  braidMaze(lastGrid, makeRng((p.seed || String(Date.now())) + "::braid"), braidFactor);

  // entry/exit
  const rngOpen = makeRng((p.seed || String(Date.now())) + "::openings");
  const {entry, exit} = chooseEntryExit(p.cols, p.rows, rngOpen, p.entrySide, p.exitSide, p.sameRow);
  lastEntry = entry;
  lastExit = exit;

  // open boundary walls in grid so solver matches openings
  openBoundary(lastGrid, lastEntry);
  openBoundary(lastGrid, lastExit);

  drawMazeToCanvas(canvas, lastGrid, p.cell, p.road, p.topPad, p.showSolution);

  lastParams = p;
  updateSizeInfo();
}

/* ===========================
   URL params read/write
   =========================== */
function applyURLParamsToUI() {
  const sp = new URLSearchParams(window.location.search);
  const setIf = (id, key) => {
    if (sp.has(key)) document.getElementById(id).value = sp.get(key);
  };
  setIf('cols','cols');
  setIf('rows','rows');
  setIf('cell','cell');
  setIf('road','road');
  setIf('topPad','topPad');
  setIf('seed','seed');
  setIf('entrySide','entry');
  setIf('exitSide','exit');
  setIf('difficulty','diff');
  setIf('preset','preset');
  if (sp.has("print")) setToggle(document.getElementById("printToggle"), sp.get("print")==="1");
  if (sp.has("solution")) setToggle(document.getElementById("solutionToggle"), sp.get("solution")==="1");
  if (sp.has("sameRow")) setToggle(document.getElementById("sameRowToggle"), sp.get("sameRow")==="1");
  if (sp.has("dpi")) document.getElementById("exportDpi").value = sp.get("dpi");
  if (sp.has("topIn")) document.getElementById("topIn").value = sp.get("topIn");
}

/* ===========================
   Batch download (sequential)
   - No ZIP to keep it dependency-free.
   =========================== */
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

async function batchGenerate(){
  const count = clamp(toInt(document.getElementById("batchCount").value, 20), 2, 200);
  const fmt = document.getElementById("batchFormat").value;

  // base params from UI
  const p = readParamsFromUI();
  const diff = document.getElementById("difficulty").value;
  const braidFactor = braidFactorFromDifficulty(diff);

  const printMode = getToggle(document.getElementById("printToggle"));
  const dpi = toInt(document.getElementById("exportDpi").value, 300);
  const topIn = clamp(toFloat(document.getElementById("topIn").value, 1.0), 0, 3);
  const showSol = getToggle(document.getElementById("solutionToggle"));

  setWarn(`Batch: ${count} (${fmt.toUpperCase()})…`, "ok");

  for (let i=1;i<=count;i++){
    const seedBase = p.seed || "APML";
    const seed = `${seedBase}::${String(i).padStart(3,"0")}`;

    const rngMaze = makeRng(seed);
    const grid = generateMaze(p.cols, p.rows, rngMaze);
    braidMaze(grid, makeRng(seed+"::braid"), braidFactor);

    const rngOpen = makeRng(seed+"::openings");
    const {entry, exit} = chooseEntryExit(p.cols, p.rows, rngOpen, p.entrySide, p.exitSide, p.sameRow);
    lastEntry = entry; lastExit = exit;
    openBoundary(grid, lastEntry);
    openBoundary(grid, lastExit);

    if (fmt === "svg"){
      const svg = mazeToSVG(grid, {
        cell: p.cell, road: p.road, topPad: p.topPad,
        showSolution: showSol,
        printMode,
        dpi,
        topIn
      });
      downloadText(`ap-mazelab-${String(i).padStart(3,"0")}.svg`, svg, "image/svg+xml");
    } else {
      // png: in print mode, render offscreen at DPI; else render at preview px
      if (!printMode){
        const off = document.createElement("canvas");
        drawMazeToCanvas(off, grid, p.cell, p.road, p.topPad, showSol);
        const blob = await new Promise(res=>off.toBlob(res,"image/png"));
        downloadBlob(`ap-mazelab-${String(i).padStart(3,"0")}.png`, blob);
      } else {
        const Wpx = Math.round(10*dpi);
        const Hpx = Math.round(8*dpi);
        const topPadPx = Math.round(topIn*dpi);
        const cellFit = Math.floor(Math.min((Wpx-2)/p.cols, (Hpx-topPadPx-2)/p.rows));
        const cell = Math.max(2, cellFit);
        const road = Math.max(2, Math.round(p.road * (cell / p.cell)));

        const off = document.createElement("canvas");
        drawMazeToCanvas(off, grid, cell, road, topPadPx, showSol);
        const blob = await new Promise(res=>off.toBlob(res,"image/png"));
        downloadBlob(`ap-mazelab-10x8-${dpi}dpi-${String(i).padStart(3,"0")}.png`, blob);
      }
    }

    // small delay to keep browsers happy
    await sleep(120);
  }

  setWarn("Batch listo ✅", "autoHide");
  updateSizeInfo();
}

/* ===========================
   Wire UI events
   =========================== */
document.getElementById('gen').addEventListener('click', regenerate);

document.getElementById('randSeed').addEventListener('click', () => {
  const stamp = Date.now().toString(36).toUpperCase();
  const rnd = Math.random().toString(36).slice(2, 7).toUpperCase();
  document.getElementById('seed').value = `APML-${stamp}-${rnd}`;
  regenerate();
});

document.getElementById('svg').addEventListener('click', () => {
  if (!lastGrid) regenerate();
  const p = lastParams || readParamsFromUI();
  const printMode = getToggle(document.getElementById("printToggle"));
  const dpi = toInt(document.getElementById("exportDpi").value, 300);
  const topIn = clamp(toFloat(document.getElementById("topIn").value, 1.0), 0, 3);

  const svg = mazeToSVG(lastGrid, {
    cell: p.cell, road: p.road, topPad: p.topPad,
    showSolution: getToggle(document.getElementById("solutionToggle")),
    printMode,
    dpi,
    topIn
  });
  downloadText('ap-mazelab-maze.svg', svg, 'image/svg+xml');
});

document.getElementById('png').addEventListener('click', exportPNG);
document.getElementById('pdf').addEventListener('click', exportPDF);

document.getElementById('share').addEventListener('click', async () => {
  const p = lastParams || readParamsFromUI();
  const url = buildShareURL({
    lang: currentLang,
    cols: p.cols, rows: p.rows, cell: p.cell, road: p.road, topPad: p.topPad,
    seed: p.seed || "",
    entry: p.entrySide,
    exit: p.exitSide,
    sameRow: p.sameRow ? 1 : 0,
    solution: getToggle(document.getElementById("solutionToggle")) ? 1 : 0,
    print: getToggle(document.getElementById("printToggle")) ? 1 : 0,
    dpi: document.getElementById("exportDpi").value,
    topIn: document.getElementById("topIn").value,
    diff: document.getElementById("difficulty").value,
    preset: document.getElementById("preset").value
  });

  try{
    await navigator.clipboard.writeText(url);
    setWarn(i18n[currentLang].linkCopied, "autoHide");
  }catch{
    prompt("Copy this link:", url);
  }
});

document.getElementById('reset').addEventListener('click', () => {
  document.getElementById("difficulty").value = "custom";
  document.getElementById("preset").value = "none";
  document.getElementById("cols").value = 30;
  document.getElementById("rows").value = 20;
  document.getElementById("cell").value = 24;
  document.getElementById("road").value = 10;
  document.getElementById("topPad").value = 90;
  document.getElementById("seed").value = "";
  document.getElementById("entrySide").value = "random";
  document.getElementById("exitSide").value = "random";
  document.getElementById("exportDpi").value = "300";
  document.getElementById("topIn").value = "1.0";
  setToggle(document.getElementById("printToggle"), false);
  setToggle(document.getElementById("solutionToggle"), false);
  setToggle(document.getElementById("sameRowToggle"), false);
  hideWarn();
  regenerate();
});

document.getElementById('about').addEventListener('click', () => {
  alert(i18n[currentLang].aboutText);
});

document.getElementById('batch').addEventListener('click', batchGenerate);

document.getElementById("difficulty").addEventListener("change", (e)=>{
  if (e.target.value !== "custom") applyDifficultyPreset(e.target.value);
  regenerate();
});

document.getElementById("preset").addEventListener("change", (e)=>{
  applyPreset(e.target.value);
  regenerate();
});

// Enter key => generate
document.addEventListener("keydown", (e)=>{
  if (e.key === "Enter" && (e.target.tagName === "INPUT" || e.target.tagName === "SELECT")){
    regenerate();
  }
});

// Language selector
document.getElementById("lang").addEventListener("change", (e) => {
  applyLang(e.target.value);
  updateSizeInfo();
});

// Toggles
function hookToggle(id, onChange){
  const el = document.getElementById(id);
  const act = ()=>{
    setToggle(el, !getToggle(el));
    onChange?.();
  };
  el.addEventListener("click", act);
  el.addEventListener("keydown", (e)=>{ if (e.key===" " || e.key==="Enter"){ e.preventDefault(); act(); } });
}
hookToggle("printToggle", ()=>{ updateSizeInfo(); });
hookToggle("solutionToggle", ()=>{ regenerate(); });
hookToggle("sameRowToggle", ()=>{ regenerate(); });

/* ===========================
   Init
   =========================== */
applyURLParamsToUI();
applyLang(detectLang());
regenerate();
updateSizeInfo();
</script>
</body>
</html>